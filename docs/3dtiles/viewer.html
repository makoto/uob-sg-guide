<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Queenstown 3D Buildings</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.124/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.124/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; font-family: sans-serif; font-size: 13px; z-index: 1; }
    #info h3 { margin: 0 0 5px 0; }
    #picked { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px 15px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 1; display: none; max-width: 400px; }
    #basemap-toggle { background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 3px 10px; font-family: sans-serif; font-size: 12px; cursor: pointer; margin-top: 6px; }
    #basemap-toggle:hover { background: rgba(255,255,255,0.3); }
    .legend { margin-top: 8px; font-size: 11px; line-height: 1.6; }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 14px; height: 10px; border-radius: 2px; flex-shrink: 0; }
    #layer-panel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 0; border-radius: 5px; font-family: sans-serif; font-size: 12px; z-index: 1; min-width: 220px; max-height: calc(100vh - 30px); overflow-y: auto; }
    #layer-panel-header { padding: 8px 12px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.15); }
    #layer-panel-header:hover { background: rgba(255,255,255,0.1); border-radius: 5px 5px 0 0; }
    #layer-panel-body { padding: 6px 0; }
    .layer-group-title { color: #aaa; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; padding: 6px 12px 2px; margin-top: 2px; }
    .layer-row { display: flex; align-items: center; gap: 6px; padding: 3px 12px; cursor: pointer; }
    .layer-row:hover { background: rgba(255,255,255,0.08); }
    .layer-row input[type="checkbox"] { margin: 0; cursor: pointer; }
    .layer-color { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .layer-label { flex: 1; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="info">
    <h3>Queenstown 3D Buildings</h3>
    <div>8,671 buildings | Click a building for details</div>
    <button id="basemap-toggle" onclick="toggleBasemap()">&#9788; Light</button>
    <div class="legend">
      <div style="color:#999; margin-bottom:2px;">Building height</div>
      <div class="legend-item"><span class="legend-swatch" style="background:red"></span> &gt; 100 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:orange"></span> 50 &ndash; 100 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:yellow"></span> 30 &ndash; 50 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:cyan"></span> 15 &ndash; 30 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:white"></span> &le; 15 m</div>
    </div>
  </div>
  <div id="layer-panel">
    <div id="layer-panel-header" onclick="toggleLayerPanel()">
      <span>Layers</span><span id="layer-panel-arrow">&#9660;</span>
    </div>
    <div id="layer-panel-body"></div>
  </div>
  <div id="picked"></div>
  <script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5NDFhNDRiNS1kN2QzLTRkODEtYWE3Ny1iNjNiYmJhYzIxNWYiLCJpZCI6Mzg5OTAzLCJpYXQiOjE3NzA4ODU4MTN9.dB69NlIicj_aXa_DecgmHGUKhkD055fGqZCz2t1Yan0';

    const cartoCredit = new Cesium.Credit('&copy; <a href="https://carto.com/">CARTO</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>');
    const cartoDark = new Cesium.UrlTemplateImageryProvider({
      url: 'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
      credit: cartoCredit, minimumLevel: 0, maximumLevel: 19,
    });
    const cartoLight = new Cesium.UrlTemplateImageryProvider({
      url: 'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
      credit: cartoCredit, minimumLevel: 0, maximumLevel: 19,
    });

    let isDark = true;
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrain: Cesium.Terrain.fromWorldTerrain(),
      baseLayer: new Cesium.ImageryLayer(cartoDark),
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      animation: false,
      timeline: false,
    });

    // State
    let tilesetRef = null;
    let tilesetCartographic = null;
    // Apply height offset along surface normal
    function setHeightOffset(offset) {
      if (!tilesetRef || !tilesetCartographic) return;
      const surface = Cesium.Cartesian3.fromRadians(
        tilesetCartographic.longitude, tilesetCartographic.latitude, 0
      );
      const offsetPos = Cesium.Cartesian3.fromRadians(
        tilesetCartographic.longitude, tilesetCartographic.latitude, offset
      );
      const translation = Cesium.Cartesian3.subtract(
        offsetPos, surface, new Cesium.Cartesian3()
      );
      tilesetRef.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
    }

    async function loadTileset() {
      try {
        const tileset = await Cesium.Cesium3DTileset.fromUrl('tileset.json');
        viewer.scene.primitives.add(tileset);
        tilesetRef = tileset;

        // Get tileset center for height offset calculations
        tilesetCartographic = Cesium.Cartographic.fromCartesian(
          tileset.boundingSphere.center
        );
        console.log('Tileset center (degrees):',
          Cesium.Math.toDegrees(tilesetCartographic.longitude).toFixed(4),
          Cesium.Math.toDegrees(tilesetCartographic.latitude).toFixed(4),
          'ellipsoid height:', tilesetCartographic.height.toFixed(1)
        );

        // Sample terrain height and auto-clamp buildings to ground
        let autoOffset = 0;
        try {
          const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1);
          const positions = [Cesium.Cartographic.clone(tilesetCartographic)];
          const samples = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);
          const terrainHeight = samples[0].height || 0;
          console.log('Terrain height at center:', terrainHeight);
          console.log('Tileset ellipsoid height:', tilesetCartographic.height.toFixed(1));
          // Building bases are at ellipsoid height 0; terrain is at terrainHeight above ellipsoid
          // Offset = +terrainHeight to lift buildings up to terrain level
          autoOffset = terrainHeight;
          autoOffset = Math.round(autoOffset);
          document.getElementById('info').innerHTML +=
            '<br><small>Terrain: ' + terrainHeight.toFixed(1) + 'm | Auto-offset: ' + autoOffset + 'm</small>';
        } catch(e) {
          console.warn('Could not sample terrain:', e);
        }

        // Apply auto-offset to clamp buildings to terrain
        setHeightOffset(autoOffset);

        // Fly to Queenstown
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(103.7885, 1.2870, 2000),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-45),
            roll: 0,
          }
        });

        // Style by height
        tileset.style = new Cesium.Cesium3DTileStyle({
          color: {
            conditions: [
              ['${height_m} > 100', 'color("red", 0.8)'],
              ['${height_m} > 50', 'color("orange", 0.8)'],
              ['${height_m} > 30', 'color("yellow", 0.8)'],
              ['${height_m} > 15', 'color("cyan", 0.8)'],
              ['true', 'color("white", 0.7)']
            ]
          }
        });
      } catch (error) {
        console.error('Error loading tileset:', error);
        document.getElementById('info').innerHTML +=
          '<br><span style="color:red">Error: ' + error.message + '</span>';
      }
    }
    loadTileset();

    // Load Queenstown boundary and draw as ground-clamped polyline
    fetch('queenstown-boundary.geojson')
      .then(r => r.json())
      .then(geojson => {
        const coords = geojson.features[0].geometry.coordinates;
        // Handle Polygon or MultiPolygon
        const rings = geojson.features[0].geometry.type === 'MultiPolygon'
          ? coords.flat() : coords;
        rings.forEach(ring => {
          const positions = ring.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
          const entity = viewer.entities.add({
            polyline: {
              positions: positions,
              clampToGround: true,
              width: 4,
              material: new Cesium.PolylineGlowMaterialProperty({
                glowPower: 0.2,
                color: Cesium.Color.MAGENTA,
              }),
            }
          });
          builtinEntities.boundary.push(entity);
        });
        console.log('Boundary drawn:', rings.length, 'rings');
      })
      .catch(err => console.error('Boundary error:', err));

    // Load subzone boundaries
    fetch('../geo/queenstown-subzones.geojson')
      .then(r => r.json())
      .then(geojson => {
        geojson.features.forEach(feature => {
          const name = feature.properties.SUBZONE_N;
          const coords = feature.geometry.coordinates;
          const rings = feature.geometry.type === 'MultiPolygon'
            ? coords.flat() : coords;
          rings.forEach(ring => {
            const positions = ring.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
            const entity = viewer.entities.add({
              polyline: {
                positions: positions,
                clampToGround: true,
                width: 2,
                material: Cesium.Color.CYAN.withAlpha(0.6),
              }
            });
            builtinEntities.subzones.push(entity);
          });
          // Label at centroid
          const allLng = coords.flat(2).filter((_, i) => i % 2 === 0 || (Array.isArray(coords[0][0][0]) ? false : true));
          // Simple centroid from first ring
          const ring0 = rings[0];
          const cLng = ring0.reduce((s, p) => s + p[0], 0) / ring0.length;
          const cLat = ring0.reduce((s, p) => s + p[1], 0) / ring0.length;
          const labelEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(cLng, cLat),
            label: {
              text: name,
              font: '11px sans-serif',
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scaleByDistance: new Cesium.NearFarScalar(500, 1.0, 5000, 0.4),
            }
          });
          builtinEntities.subzones.push(labelEntity);
        });
        console.log('Subzones drawn:', geojson.features.length);
      })
      .catch(err => console.error('Subzones error:', err));

    // Click handler to show building info
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function(movement) {
      const picked = viewer.scene.pick(movement.position);
      const pickedDiv = document.getElementById('picked');
      if (picked && picked.getProperty) {
        const name = picked.getProperty('name') || '(unnamed)';
        const building = picked.getProperty('building') || '';
        const height = picked.getProperty('height_m') || '';
        const source = picked.getProperty('height_source') || '';
        const dsource = picked.getProperty('data_source') || '';
        const levels = picked.getProperty('building_levels') || '';
        const year = picked.getProperty('hdb_year_completed') || '';

        let html = `<b>${name}</b><br>`;
        html += `Type: ${building}<br>`;
        html += `Height: ${height}m`;
        if (levels) html += ` (${levels} storeys)`;
        html += `<br>`;
        html += `Height source: ${source}<br>`;
        html += `Data source: ${dsource}<br>`;
        if (year) html += `Year completed: ${year}<br>`;

        pickedDiv.innerHTML = html;
        pickedDiv.style.display = 'block';
      } else {
        pickedDiv.style.display = 'none';
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // ---------------------------------------------------------------
    // Layer panel
    // ---------------------------------------------------------------
    let layerPanelOpen = true;
    function toggleLayerPanel() {
      layerPanelOpen = !layerPanelOpen;
      document.getElementById('layer-panel-body').style.display = layerPanelOpen ? '' : 'none';
      document.getElementById('layer-panel-arrow').innerHTML = layerPanelOpen ? '&#9660;' : '&#9654;';
    }

    // Layer definitions: { id, label, file, color, type, group, onByDefault }
    const LAYERS = [
      // Boundaries (loaded separately above, managed via entity show/hide)
      { id: 'boundary', label: 'Queenstown boundary', color: '#ff00ff', group: 'Boundaries', onByDefault: true, builtin: true },
      { id: 'subzones', label: 'Subzones', color: '#00ffff', group: 'Boundaries', onByDefault: true, builtin: true },
      // Food & Daily Needs
      { id: 'hawker', label: 'Hawker centres', file: '../geo/queenstown-hawker-centres.geojson', color: '#ff6b35', group: 'Food & Daily Needs', type: 'point' },
      { id: 'supermarket', label: 'Supermarkets', file: '../geo/queenstown-supermarkets.geojson', color: '#4ecdc4', group: 'Food & Daily Needs', type: 'point' },
      // Transit
      { id: 'mrt', label: 'MRT exits', file: '../geo/queenstown-mrt-exits.geojson', color: '#2c5f8a', group: 'Transit', type: 'point' },
      // Green & Recreation
      { id: 'parks', label: 'Parks', file: '../geo/queenstown-parks.geojson', color: '#45b649', group: 'Green & Recreation', type: 'point' },
      { id: 'parkfac', label: 'Park facilities', file: '../geo/queenstown-park-facilities.geojson', color: '#7bc67e', group: 'Green & Recreation', type: 'point' },
      { id: 'parkconn', label: 'Park connectors', file: '../geo/queenstown-park-connectors.geojson', color: '#44ff44', group: 'Green & Recreation', type: 'line' },
      // Active Mobility
      { id: 'cycling', label: 'Cycling paths', file: '../geo/queenstown-cycling-paths.geojson', color: '#00ff88', group: 'Active Mobility', type: 'line' },
      // Community
      { id: 'cc', label: 'Community clubs', file: '../geo/queenstown-community-clubs.geojson', color: '#9b59b6', group: 'Community', type: 'point' },
      { id: 'gym', label: 'Gyms', file: '../geo/queenstown-gyms.geojson', color: '#e74c3c', group: 'Community', type: 'point' },
      { id: 'preschool', label: 'Pre-schools', file: '../geo/queenstown-preschools.geojson', color: '#f39c12', group: 'Community', type: 'point' },
      { id: 'chas', label: 'CHAS clinics', file: '../geo/queenstown-chas-clinics.geojson', color: '#e84393', group: 'Community', type: 'point' },
    ];

    // Track loaded data sources and built-in entity collections
    const layerState = {};  // id -> { dataSource, loaded, visible }

    // Tag boundary/subzone entities so we can toggle them
    // We'll retroactively tag them after they load. Store entity references.
    const builtinEntities = { boundary: [], subzones: [] };

    function buildLayerPanel() {
      const body = document.getElementById('layer-panel-body');
      let currentGroup = null;
      LAYERS.forEach(layer => {
        if (layer.group !== currentGroup) {
          currentGroup = layer.group;
          const title = document.createElement('div');
          title.className = 'layer-group-title';
          title.textContent = currentGroup;
          body.appendChild(title);
        }
        const row = document.createElement('label');
        row.className = 'layer-row';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = !!layer.onByDefault;
        cb.addEventListener('change', () => onLayerToggle(layer.id, cb.checked));

        const swatch = document.createElement('span');
        swatch.className = 'layer-color';
        swatch.style.background = layer.color;
        if (layer.type === 'line') {
          swatch.style.borderRadius = '2px';
          swatch.style.width = '14px';
          swatch.style.height = '4px';
        }

        const label = document.createElement('span');
        label.className = 'layer-label';
        label.textContent = layer.label;

        row.appendChild(cb);
        row.appendChild(swatch);
        row.appendChild(label);
        body.appendChild(row);

        layerState[layer.id] = { dataSource: null, loaded: false, visible: cb.checked };
      });
    }

    async function onLayerToggle(id, visible) {
      layerState[id].visible = visible;
      const layer = LAYERS.find(l => l.id === id);

      // Built-in layers (boundary / subzones) â€” toggle entity visibility
      if (layer.builtin) {
        builtinEntities[id].forEach(e => { e.show = visible; });
        return;
      }

      // Lazy-load on first toggle-on
      if (visible && !layerState[id].loaded) {
        layerState[id].loaded = true;
        try {
          const ds = await Cesium.GeoJsonDataSource.load(layer.file, {
            clampToGround: true,
            stroke: Cesium.Color.fromCssColorString(layer.color),
            strokeWidth: layer.type === 'line' ? 3 : 1,
            markerColor: Cesium.Color.fromCssColorString(layer.color),
            markerSize: 18,
          });
          // For point layers, override billboard with simple colored circles
          if (layer.type === 'point') {
            ds.entities.values.forEach(entity => {
              if (entity.billboard) {
                entity.billboard = undefined;
                entity.point = new Cesium.PointGraphics({
                  pixelSize: 7,
                  color: Cesium.Color.fromCssColorString(layer.color),
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 1,
                  heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                  disableDepthTestDistance: Number.POSITIVE_INFINITY,
                });
              }
            });
          }
          viewer.dataSources.add(ds);
          layerState[id].dataSource = ds;
        } catch (err) {
          console.warn(`Failed to load layer ${layer.label}:`, err);
          layerState[id].loaded = false;
        }
        return;
      }

      if (layerState[id].dataSource) {
        layerState[id].dataSource.show = visible;
      }
    }

    buildLayerPanel();

    // Basemap toggle
    function toggleBasemap() {
      const layers = viewer.imageryLayers;
      layers.remove(layers.get(0));
      isDark = !isDark;
      layers.addImageryProvider(isDark ? cartoDark : cartoLight, 0);
      const btn = document.getElementById('basemap-toggle');
      btn.innerHTML = isDark ? '&#9788; Light' : '&#9790; Dark';
    }
  </script>
</body>
</html>
