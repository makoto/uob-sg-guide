<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Queenstown 3D Buildings</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.124/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.124/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px 15px; border-radius: 5px; font-family: sans-serif; font-size: 13px; z-index: 1; }
    #info h3 { margin: 0 0 5px 0; }
    #picked { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px 15px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 1; display: none; max-width: 400px; }
    #basemap-toggle { background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 3px 10px; font-family: sans-serif; font-size: 12px; cursor: pointer; margin-top: 6px; }
    #basemap-toggle:hover { background: rgba(255,255,255,0.3); }
    .legend { margin-top: 8px; font-size: 11px; line-height: 1.6; }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 14px; height: 10px; border-radius: 2px; flex-shrink: 0; }
    #layer-panel { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 0; border-radius: 5px; font-family: sans-serif; font-size: 12px; z-index: 1; min-width: 220px; max-height: calc(100vh - 30px); overflow-y: auto; }
    #layer-panel-header { padding: 8px 12px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.15); }
    #layer-panel-header:hover { background: rgba(255,255,255,0.1); border-radius: 5px 5px 0 0; }
    #layer-panel-body { padding: 6px 0; }
    .layer-group-title { color: #aaa; font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; padding: 6px 12px 2px; margin-top: 2px; }
    .layer-row { display: flex; align-items: center; gap: 6px; padding: 3px 12px; cursor: pointer; }
    .layer-row:hover { background: rgba(255,255,255,0.08); }
    .layer-row input[type="checkbox"] { margin: 0; cursor: pointer; }
    .layer-color { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .layer-label { flex: 1; }
    .choropleth-select { width: 100%; padding: 4px 6px; background: rgba(255,255,255,0.12); color: white; border: 1px solid rgba(255,255,255,0.25); border-radius: 3px; font-family: sans-serif; font-size: 12px; margin: 4px 12px; box-sizing: border-box; width: calc(100% - 24px); cursor: pointer; }
    .choropleth-select option { background: #222; color: white; }
    .provenance-bar { display: flex; gap: 6px; padding: 6px 12px; border-bottom: 1px solid rgba(255,255,255,0.1); }
    .provenance-btn { flex: 1; padding: 4px 8px; border: 1px solid rgba(255,255,255,0.25); border-radius: 3px; background: rgba(255,255,255,0.12); color: white; font-size: 11px; cursor: pointer; text-align: center; user-select: none; }
    .provenance-btn.active { background: rgba(255,255,255,0.25); border-color: rgba(255,255,255,0.5); }
    .provenance-btn:hover { background: rgba(255,255,255,0.2); }
    .source-badge { font-size: 9px; color: #888; margin-left: 4px; flex-shrink: 0; }
    #choropleth-legend { margin: 4px 12px 6px; display: none; }
    #choropleth-legend .gradient-bar { height: 10px; border-radius: 2px; background: linear-gradient(to right, #ffffb2, #fecc5c, #fd8d3c, #f03b20, #bd0026); }
    #choropleth-legend .legend-labels { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-top: 2px; }
    #layer-legend { margin-top: 8px; font-size: 11px; display: none; }
    #layer-legend .layer-legend-section { margin-bottom: 6px; }
    #layer-legend .layer-legend-title { color: #999; margin-bottom: 2px; }
    #layer-legend .layer-legend-gradient { height: 10px; border-radius: 2px; margin-top: 2px; }
    #layer-legend .layer-legend-labels { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-top: 2px; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="info">
    <h3>Queenstown 3D Buildings</h3>
    <div>8,671 buildings | 26 layers | 25 metrics | Click for details</div>
    <button id="basemap-toggle" onclick="toggleBasemap()">&#9788; Light</button>
    <div class="legend">
      <div style="color:#999; margin-bottom:2px;">Building height</div>
      <div class="legend-item"><span class="legend-swatch" style="background:red"></span> &gt; 100 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:orange"></span> 50 &ndash; 100 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:yellow"></span> 30 &ndash; 50 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:cyan"></span> 15 &ndash; 30 m</div>
      <div class="legend-item"><span class="legend-swatch" style="background:white"></span> &le; 15 m</div>
    </div>
    <div id="layer-legend"></div>
  </div>
  <div id="layer-panel">
    <div id="layer-panel-header" onclick="toggleLayerPanel()">
      <span>Layers</span><span id="layer-panel-arrow">&#9660;</span>
    </div>
    <div id="layer-panel-body"></div>
  </div>
  <div id="picked"></div>
  <script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5NDFhNDRiNS1kN2QzLTRkODEtYWE3Ny1iNjNiYmJhYzIxNWYiLCJpZCI6Mzg5OTAzLCJpYXQiOjE3NzA4ODU4MTN9.dB69NlIicj_aXa_DecgmHGUKhkD055fGqZCz2t1Yan0';

    const cartoCredit = new Cesium.Credit('&copy; <a href="https://carto.com/">CARTO</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>');
    const cartoDark = new Cesium.UrlTemplateImageryProvider({
      url: 'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
      credit: cartoCredit, minimumLevel: 0, maximumLevel: 19,
    });
    const cartoLight = new Cesium.UrlTemplateImageryProvider({
      url: 'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
      credit: cartoCredit, minimumLevel: 0, maximumLevel: 19,
    });

    let isDark = true;
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrain: Cesium.Terrain.fromWorldTerrain(),
      baseLayer: new Cesium.ImageryLayer(cartoDark),
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      animation: false,
      timeline: false,
    });

    // State
    let tilesetRef = null;
    let tilesetCartographic = null;
    // Apply height offset along surface normal
    function setHeightOffset(offset) {
      if (!tilesetRef || !tilesetCartographic) return;
      const surface = Cesium.Cartesian3.fromRadians(
        tilesetCartographic.longitude, tilesetCartographic.latitude, 0
      );
      const offsetPos = Cesium.Cartesian3.fromRadians(
        tilesetCartographic.longitude, tilesetCartographic.latitude, offset
      );
      const translation = Cesium.Cartesian3.subtract(
        offsetPos, surface, new Cesium.Cartesian3()
      );
      tilesetRef.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
    }

    async function loadTileset() {
      try {
        const tileset = await Cesium.Cesium3DTileset.fromUrl('tileset.json');
        viewer.scene.primitives.add(tileset);
        tilesetRef = tileset;

        // Get tileset center for height offset calculations
        tilesetCartographic = Cesium.Cartographic.fromCartesian(
          tileset.boundingSphere.center
        );
        console.log('Tileset center (degrees):',
          Cesium.Math.toDegrees(tilesetCartographic.longitude).toFixed(4),
          Cesium.Math.toDegrees(tilesetCartographic.latitude).toFixed(4),
          'ellipsoid height:', tilesetCartographic.height.toFixed(1)
        );

        // Sample terrain height and auto-clamp buildings to ground
        let autoOffset = 0;
        try {
          const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1);
          const positions = [Cesium.Cartographic.clone(tilesetCartographic)];
          const samples = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);
          const terrainHeight = samples[0].height || 0;
          console.log('Terrain height at center:', terrainHeight);
          console.log('Tileset ellipsoid height:', tilesetCartographic.height.toFixed(1));
          // Building bases are at ellipsoid height 0; terrain is at terrainHeight above ellipsoid
          // Offset = +terrainHeight to lift buildings up to terrain level
          autoOffset = terrainHeight;
          autoOffset = Math.round(autoOffset);
          document.getElementById('info').innerHTML +=
            '<br><small>Terrain: ' + terrainHeight.toFixed(1) + 'm | Auto-offset: ' + autoOffset + 'm</small>';
        } catch(e) {
          console.warn('Could not sample terrain:', e);
        }

        // Apply auto-offset to clamp buildings to terrain
        setHeightOffset(autoOffset);

        // Fly to Queenstown
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(103.7885, 1.2870, 2000),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-45),
            roll: 0,
          }
        });

        // Style by height
        tileset.style = new Cesium.Cesium3DTileStyle({
          color: {
            conditions: [
              ['${height_m} > 100', 'color("red", 0.8)'],
              ['${height_m} > 50', 'color("orange", 0.8)'],
              ['${height_m} > 30', 'color("yellow", 0.8)'],
              ['${height_m} > 15', 'color("cyan", 0.8)'],
              ['true', 'color("white", 0.7)']
            ]
          }
        });
      } catch (error) {
        console.error('Error loading tileset:', error);
        document.getElementById('info').innerHTML +=
          '<br><span style="color:red">Error: ' + error.message + '</span>';
      }
    }
    loadTileset();

    // Load Queenstown boundary and draw as ground-clamped polyline
    fetch('queenstown-boundary.geojson')
      .then(r => r.json())
      .then(geojson => {
        const coords = geojson.features[0].geometry.coordinates;
        // Handle Polygon or MultiPolygon
        const rings = geojson.features[0].geometry.type === 'MultiPolygon'
          ? coords.flat() : coords;
        rings.forEach(ring => {
          const positions = ring.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
          const entity = viewer.entities.add({
            polyline: {
              positions: positions,
              clampToGround: true,
              width: 4,
              material: new Cesium.PolylineGlowMaterialProperty({
                glowPower: 0.2,
                color: Cesium.Color.MAGENTA,
              }),
            }
          });
          builtinEntities.boundary.push(entity);
        });
        console.log('Boundary drawn:', rings.length, 'rings');
      })
      .catch(err => console.error('Boundary error:', err));

    // Load subzone boundaries
    fetch('../geo/queenstown-subzones.geojson')
      .then(r => r.json())
      .then(geojson => {
        geojson.features.forEach(feature => {
          const name = feature.properties.SUBZONE_N;
          const coords = feature.geometry.coordinates;
          const rings = feature.geometry.type === 'MultiPolygon'
            ? coords.flat() : coords;
          rings.forEach(ring => {
            const positions = ring.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
            const entity = viewer.entities.add({
              polyline: {
                positions: positions,
                clampToGround: true,
                width: 2,
                material: Cesium.Color.CYAN.withAlpha(0.6),
              }
            });
            builtinEntities.subzones.push(entity);
          });
          // Label at centroid
          const allLng = coords.flat(2).filter((_, i) => i % 2 === 0 || (Array.isArray(coords[0][0][0]) ? false : true));
          // Simple centroid from first ring
          const ring0 = rings[0];
          const cLng = ring0.reduce((s, p) => s + p[0], 0) / ring0.length;
          const cLat = ring0.reduce((s, p) => s + p[1], 0) / ring0.length;
          const labelEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(cLng, cLat),
            label: {
              text: name,
              font: '11px sans-serif',
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              scaleByDistance: new Cesium.NearFarScalar(500, 1.0, 5000, 0.4),
            }
          });
          builtinEntities.subzones.push(labelEntity);
        });
        console.log('Subzones drawn:', geojson.features.length);
      })
      .catch(err => console.error('Subzones error:', err));

    // Click handler to show building info
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function(movement) {
      const picked = viewer.scene.pick(movement.position);
      const pickedDiv = document.getElementById('picked');
      if (picked && picked.getProperty) {
        const name = picked.getProperty('name') || '(unnamed)';
        const building = picked.getProperty('building') || '';
        const height = picked.getProperty('height_m') || '';
        const source = picked.getProperty('height_source') || '';
        const dsource = picked.getProperty('data_source') || '';
        const levels = picked.getProperty('building_levels') || '';
        const year = picked.getProperty('hdb_year_completed') || '';

        let html = `<b>${name}</b><br>`;
        html += `Type: ${building}<br>`;
        html += `Height: ${height}m`;
        if (levels) html += ` (${levels} storeys)`;
        html += `<br>`;
        html += `Height source: ${source}<br>`;
        html += `Data source: ${dsource}<br>`;
        if (year) html += `Year completed: ${year}<br>`;

        pickedDiv.innerHTML = html;
        pickedDiv.style.display = 'block';
      } else if (picked && picked.id && picked.id.properties) {
        // GeoJSON entity (e.g. HDB blocks, height control)
        const props = picked.id.properties;
        const gv = (k) => props[k] ? props[k].getValue() : null;
        let html = '';
        if (gv('hdb_match')) {
          // HDB block info
          const name = gv('name') || gv('addr_housenumber') || '(unnamed)';
          const street = gv('addr_street') || '';
          html = `<b>${name}</b>`;
          if (street) html += ` ${street}`;
          html += '<br>';
          const year = gv('hdb_year_completed');
          if (year) html += `Year completed: ${year}<br>`;
          const units = gv('hdb_total_dwelling_units');
          if (units) html += `Dwelling units: ${units}<br>`;
          if (gv('hdb_residential') === 'Y') html += 'Residential ';
          if (gv('hdb_commercial') === 'Y') html += 'Commercial ';
          if (gv('hdb_market_hawker') === 'Y') html += 'Market/Hawker ';
          html += '<br>';
        } else if (gv('HT_CTL_TXT')) {
          html = `<b>Height control zone</b><br>`;
          html += `Max storeys: ${gv('HT_CTL_TXT')}<br>`;
          const typ = gv('HT_CTL_TYP');
          if (typ) html += `Type: ${typ}<br>`;
        } else if (gv('ndvi') !== null && gv('cell_id') !== null) {
          // RS grid cell
          html = `<b>Grid cell #${gv('cell_id')}</b> (100m)<br>`;
          html += `NDVI: ${gv('ndvi')}<br>`;
          html += `NDBI: ${gv('ndbi')}<br>`;
          html += `LST: ${gv('lst_c')} °C<br>`;
          html += `Canopy: ${gv('canopy_pct')}%<br>`;
        } else if (gv('ndvi_mean') !== null) {
          // Remote sensing subzone
          const name = gv('subzone_name') || '(subzone)';
          html = `<b>${name}</b> (Remote Sensing)<br>`;
          html += `NDVI: ${gv('ndvi_mean')}<br>`;
          html += `NDBI: ${gv('ndbi_mean')}<br>`;
          html += `LST: ${gv('lst_mean_c')} °C<br>`;
          html += `Canopy cover: ${gv('canopy_cover_pct')}%<br>`;
          html += `GHSL height: ${gv('ghsl_height_mean')} m<br>`;
          html += `DSM: ${gv('dsm_mean')} m | DEM: ${gv('dem_mean')} m<br>`;
        } else if (gv('walkability') !== null && gv('int_density') !== null) {
          // Walkability grid cell
          html = `<b>Grid cell #${gv('cell_id')}</b> (100m)<br>`;
          html += `Walkability: ${gv('walkability')}<br>`;
          html += `Intersection density: ${gv('int_density')}/km²<br>`;
          html += `Transit access: ${gv('transit_access')}<br>`;
          html += `Destination access: ${gv('dest_access')}<br>`;
        } else if (gv('betweenness') !== null) {
          // Street network edge
          const name = gv('name') || '(unnamed road)';
          html = `<b>${name}</b><br>`;
          html += `Length: ${gv('length')} m<br>`;
          html += `Betweenness: ${gv('betweenness')}<br>`;
          const hw = gv('highway');
          if (hw) html += `Type: ${hw}<br>`;
        } else if (gv('image_id')) {
          // Mapillary image
          html = `<b>Mapillary image</b><br>`;
          html += `ID: ${gv('image_id')}<br>`;
          const isPano = gv('is_pano');
          if (isPano) html += 'Panoramic<br>';
        } else {
          const name = gv('name') || gv('Name') || '(feature)';
          html = `<b>${name}</b><br>`;
        }
        pickedDiv.innerHTML = html;
        pickedDiv.style.display = 'block';
      } else {
        pickedDiv.style.display = 'none';
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // ---------------------------------------------------------------
    // Layer panel
    // ---------------------------------------------------------------
    let layerPanelOpen = true;
    function toggleLayerPanel() {
      layerPanelOpen = !layerPanelOpen;
      document.getElementById('layer-panel-body').style.display = layerPanelOpen ? '' : 'none';
      document.getElementById('layer-panel-arrow').innerHTML = layerPanelOpen ? '&#9660;' : '&#9654;';
    }

    // Layer definitions: { id, label, file, color, type, group, onByDefault, source }
    const LAYERS = [
      // Boundaries (loaded separately above, managed via entity show/hide)
      { id: 'boundary', label: 'Queenstown boundary', color: '#ff00ff', group: 'Boundaries', onByDefault: true, builtin: true },
      { id: 'subzones', label: 'Subzones', color: '#00ffff', group: 'Boundaries', onByDefault: true, builtin: true },
      // Food & Daily Needs
      { id: 'hawker', label: 'Hawker centres', file: '../geo/gov-sg/queenstown-hawker-centres.geojson', color: '#ff6b35', group: 'Food & Daily Needs', type: 'point', source: 'gov-sg' },
      { id: 'supermarket', label: 'Supermarkets', file: '../geo/gov-sg/queenstown-supermarkets.geojson', color: '#4ecdc4', group: 'Food & Daily Needs', type: 'point', source: 'gov-sg' },
      // Transit
      { id: 'mrt', label: 'MRT exits', file: '../geo/gov-sg/queenstown-mrt-exits.geojson', color: '#2c5f8a', group: 'Transit', type: 'point', source: 'gov-sg' },
      // Green & Recreation
      { id: 'parks', label: 'Parks', file: '../geo/gov-sg/queenstown-parks.geojson', color: '#45b649', group: 'Green & Recreation', type: 'point', source: 'gov-sg' },
      { id: 'parkfac', label: 'Park facilities', file: '../geo/gov-sg/queenstown-park-facilities.geojson', color: '#7bc67e', group: 'Green & Recreation', type: 'point', source: 'gov-sg' },
      { id: 'parkconn', label: 'Park connectors', file: '../geo/gov-sg/queenstown-park-connectors.geojson', color: '#44ff44', group: 'Green & Recreation', type: 'line', source: 'gov-sg' },
      // Active Mobility
      { id: 'cycling', label: 'Cycling paths', file: '../geo/gov-sg/queenstown-cycling-paths.geojson', color: '#00ff88', group: 'Active Mobility', type: 'line', source: 'gov-sg' },
      // Community
      { id: 'cc', label: 'Community clubs', file: '../geo/gov-sg/queenstown-community-clubs.geojson', color: '#9b59b6', group: 'Community', type: 'point', source: 'gov-sg' },
      { id: 'gym', label: 'Gyms', file: '../geo/gov-sg/queenstown-gyms.geojson', color: '#e74c3c', group: 'Community', type: 'point', source: 'gov-sg' },
      { id: 'preschool', label: 'Pre-schools', file: '../geo/gov-sg/queenstown-preschools.geojson', color: '#f39c12', group: 'Community', type: 'point', source: 'gov-sg' },
      { id: 'chas', label: 'CHAS clinics', file: '../geo/gov-sg/queenstown-chas-clinics.geojson', color: '#e84393', group: 'Community', type: 'point', source: 'gov-sg' },
      // Housing
      { id: 'hdb', label: 'HDB blocks', file: '../geo/global/queenstown-buildings-hdb-enriched.geojson', color: '#ff5722', group: 'Housing', type: 'point', source: 'global' },
      // Planning
      { id: 'heightctl', label: 'Height control zones', file: '../geo/gov-sg/queenstown-ura-height-control.geojson', color: '#ff9800', group: 'Planning', type: 'polygon', source: 'gov-sg' },
      // Street Network (global)
      { id: 'streetnet', label: 'Street network', file: '../geo/global/queenstown-street-network.geojson', color: '#00bcd4', group: 'Street Network', type: 'line', source: 'global' },
      // Walkability heatmaps (global)
      { id: 'walk_idx', label: 'Walkability grid', file: '../geo/global/queenstown-walkability-grid.geojson', color: '#4caf50', group: 'Street Network', type: 'polygon', source: 'global', colorField: 'walkability' },
      { id: 'walk_intdens', label: 'Intersection density grid', file: '../geo/global/queenstown-walkability-grid.geojson', color: '#2196f3', group: 'Street Network', type: 'polygon', source: 'global', colorField: 'int_density' },
      { id: 'walk_transit', label: 'Transit access grid', file: '../geo/global/queenstown-walkability-grid.geojson', color: '#9c27b0', group: 'Street Network', type: 'polygon', source: 'global', colorField: 'transit_access' },
      { id: 'walk_dest', label: 'Destination access grid', file: '../geo/global/queenstown-walkability-grid.geojson', color: '#ff9800', group: 'Street Network', type: 'polygon', source: 'global', colorField: 'dest_access' },
      // Remote Sensing — raster image overlays (global)
      { id: 'rs_ndvi', label: 'NDVI (vegetation)', rasterFile: '../geo/global/rasters/queenstown-ndvi.png', color: '#4caf50', group: 'Remote Sensing', type: 'raster', source: 'global' },
      { id: 'rs_lst', label: 'Land surface temp', rasterFile: '../geo/global/rasters/queenstown-lst.png', color: '#f44336', group: 'Remote Sensing', type: 'raster', source: 'global' },
      { id: 'rs_ndbi', label: 'Built-up (NDBI)', rasterFile: '../geo/global/rasters/queenstown-ndbi.png', color: '#ff9800', group: 'Remote Sensing', type: 'raster', source: 'global' },
      { id: 'rs_canopy', label: 'Tree canopy cover', rasterFile: '../geo/global/rasters/queenstown-canopy.png', color: '#2e7d32', group: 'Remote Sensing', type: 'raster', source: 'global' },
      // Remote Sensing — clickable 100m grid (global)
      { id: 'rs_grid', label: '100m grid (clickable)', file: '../geo/global/queenstown-rs-grid.geojson', color: '#8bc34a', group: 'Remote Sensing', type: 'polygon', source: 'global' },
      // Street-Level (global)
      { id: 'mapillary', label: 'Mapillary images', file: '../geo/global/queenstown-mapillary-gvi.geojson', color: '#03a9f4', group: 'Street-Level', type: 'point', source: 'global' },
    ];

    // Track loaded data sources and built-in entity collections
    const layerState = {};  // id -> { dataSource, loaded, visible }

    // Tag boundary/subzone entities so we can toggle them
    // We'll retroactively tag them after they load. Store entity references.
    const builtinEntities = { boundary: [], subzones: [] };

    // Provenance filter state
    const provenanceState = { 'gov-sg': true, 'global': true };

    function onProvenanceToggle(source, enabled) {
      provenanceState[source] = enabled;
      LAYERS.forEach(layer => {
        if (layer.source !== source) return;
        const cb = document.getElementById('layer-cb-' + layer.id);
        if (!cb) return;
        if (enabled) {
          // Restore — don't auto-enable, just allow interaction
        } else {
          // Hide layers of this source
          if (cb.checked) {
            cb.checked = false;
            onLayerToggle(layer.id, false);
          }
        }
        cb.disabled = !enabled;
        cb.closest('.layer-row').style.opacity = enabled ? '1' : '0.4';
      });
    }

    function buildLayerPanel() {
      const body = document.getElementById('layer-panel-body');

      // Provenance filter bar
      const provBar = document.createElement('div');
      provBar.className = 'provenance-bar';
      const btnGov = document.createElement('button');
      btnGov.className = 'provenance-btn active';
      btnGov.textContent = '\uD83C\uDDF8\uD83C\uDDEC Gov.sg';
      btnGov.addEventListener('click', () => {
        provenanceState['gov-sg'] = !provenanceState['gov-sg'];
        btnGov.classList.toggle('active', provenanceState['gov-sg']);
        onProvenanceToggle('gov-sg', provenanceState['gov-sg']);
      });
      const btnGlobal = document.createElement('button');
      btnGlobal.className = 'provenance-btn active';
      btnGlobal.textContent = '\uD83C\uDF10 Global';
      btnGlobal.addEventListener('click', () => {
        provenanceState['global'] = !provenanceState['global'];
        btnGlobal.classList.toggle('active', provenanceState['global']);
        onProvenanceToggle('global', provenanceState['global']);
      });
      provBar.appendChild(btnGov);
      provBar.appendChild(btnGlobal);
      body.appendChild(provBar);

      // Choropleth group at the top
      const choroTitle = document.createElement('div');
      choroTitle.className = 'layer-group-title';
      choroTitle.textContent = 'Choropleth';
      body.appendChild(choroTitle);

      const choroSelect = document.createElement('select');
      choroSelect.className = 'choropleth-select';
      CHOROPLETH_METRICS.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.value;
        opt.textContent = m.label;
        choroSelect.appendChild(opt);
      });
      choroSelect.addEventListener('change', () => updateChoropleth(choroSelect.value));
      body.appendChild(choroSelect);

      const legendDiv = document.createElement('div');
      legendDiv.id = 'choropleth-legend';
      legendDiv.innerHTML = '<div class="gradient-bar"></div><div class="legend-labels"><span id="choropleth-min"></span><span id="choropleth-max"></span></div>';
      body.appendChild(legendDiv);

      let currentGroup = null;
      LAYERS.forEach(layer => {
        if (layer.group !== currentGroup) {
          currentGroup = layer.group;
          const title = document.createElement('div');
          title.className = 'layer-group-title';
          title.textContent = currentGroup;
          body.appendChild(title);
        }
        const row = document.createElement('label');
        row.className = 'layer-row';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = 'layer-cb-' + layer.id;
        cb.checked = !!layer.onByDefault;
        cb.addEventListener('change', () => onLayerToggle(layer.id, cb.checked));

        const swatch = document.createElement('span');
        swatch.className = 'layer-color';
        swatch.style.background = layer.color;
        if (layer.type === 'line') {
          swatch.style.borderRadius = '2px';
          swatch.style.width = '14px';
          swatch.style.height = '4px';
        } else if (layer.type === 'raster') {
          swatch.style.borderRadius = '2px';
          swatch.style.width = '14px';
          swatch.style.height = '10px';
          swatch.style.background = `linear-gradient(to right, ${layer.color}44, ${layer.color})`;
        } else if (layer.type === 'polygon') {
          swatch.style.borderRadius = '2px';
          swatch.style.opacity = '0.5';
        }

        const label = document.createElement('span');
        label.className = 'layer-label';
        label.textContent = layer.label;

        row.appendChild(cb);
        row.appendChild(swatch);
        row.appendChild(label);

        // Source badge
        if (layer.source) {
          const badge = document.createElement('span');
          badge.className = 'source-badge';
          badge.textContent = layer.source === 'gov-sg' ? 'SG' : '\uD83C\uDF10';
          row.appendChild(badge);
        }

        body.appendChild(row);

        layerState[layer.id] = { dataSource: null, loaded: false, visible: cb.checked };
      });
    }

    async function onLayerToggle(id, visible) {
      layerState[id].visible = visible;
      const layer = LAYERS.find(l => l.id === id);

      // Built-in layers (boundary / subzones) — toggle entity visibility
      if (layer.builtin) {
        builtinEntities[id].forEach(e => { e.show = visible; });
        updateLayerLegend();
        return;
      }

      // Raster image overlays
      if (layer.type === 'raster') {
        if (visible && !layerState[id].loaded) {
          layerState[id].loaded = true;
          const rasterLayer = viewer.imageryLayers.addImageryProvider(
            new Cesium.SingleTileImageryProvider({
              url: layer.rasterFile,
              rectangle: Cesium.Rectangle.fromDegrees(103.7502, 1.2550, 103.8166, 1.3188),
            })
          );
          rasterLayer.alpha = 0.65;
          layerState[id].imageryLayer = rasterLayer;
        } else if (layerState[id].imageryLayer) {
          layerState[id].imageryLayer.show = visible;
        }
        updateLayerLegend();
        return;
      }

      // Lazy-load on first toggle-on
      if (visible && !layerState[id].loaded) {
        layerState[id].loaded = true;
        try {
          const ds = await Cesium.GeoJsonDataSource.load(layer.file, {
            clampToGround: true,
            stroke: Cesium.Color.fromCssColorString(layer.color),
            strokeWidth: layer.type === 'line' ? 3 : 1,
            markerColor: Cesium.Color.fromCssColorString(layer.color),
            markerSize: 18,
          });
          // HDB blocks — colour by year completed
          if (id === 'hdb') {
            ds.entities.values.forEach(entity => {
              if (entity.billboard) entity.billboard = undefined;
              if (entity.polygon) entity.polygon.show = false;
              const props = entity.properties;
              if (!props || !props.hdb_match || !props.hdb_match.getValue()) return;
              const year = props.hdb_year_completed ? props.hdb_year_completed.getValue() : null;
              let c = Cesium.Color.fromCssColorString('#e74c3c'); // pre-1980
              if (year && year >= 2000) c = Cesium.Color.fromCssColorString('#2ecc71');
              else if (year && year >= 1980) c = Cesium.Color.fromCssColorString('#f39c12');
              const centroid = entity.position ? entity.position.getValue(Cesium.JulianDate.now()) : null;
              entity.point = new Cesium.PointGraphics({
                pixelSize: 9,
                color: c,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 1,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
              });
            });
          }
          // Street network — colour lines by betweenness centrality
          else if (id === 'streetnet') {
            ds.entities.values.forEach(entity => {
              if (entity.polyline) {
                const props = entity.properties;
                const bc = props && props.betweenness ? props.betweenness.getValue() : 0;
                // Color ramp: low=cyan, mid=yellow, high=red
                let c = Cesium.Color.fromCssColorString('#00bcd4');
                if (bc > 0.01) c = Cesium.Color.fromCssColorString('#ff5722');
                else if (bc > 0.005) c = Cesium.Color.fromCssColorString('#ff9800');
                else if (bc > 0.002) c = Cesium.Color.fromCssColorString('#ffeb3b');
                entity.polyline.material = c;
                entity.polyline.width = bc > 0.005 ? 4 : 2;
              }
            });
          }
          // RS grid — colour 100m cells by NDVI
          else if (id === 'rs_grid') {
            ds.entities.values.forEach(entity => {
              if (entity.polygon) {
                const props = entity.properties;
                const ndvi = props && props.ndvi ? props.ndvi.getValue() : 0;
                const alpha = 0.5;
                let c;
                if (ndvi > 0.6) c = Cesium.Color.fromCssColorString('#1b5e20').withAlpha(alpha);
                else if (ndvi > 0.5) c = Cesium.Color.fromCssColorString('#2e7d32').withAlpha(alpha);
                else if (ndvi > 0.4) c = Cesium.Color.fromCssColorString('#388e3c').withAlpha(alpha);
                else if (ndvi > 0.3) c = Cesium.Color.fromCssColorString('#66bb6a').withAlpha(alpha);
                else if (ndvi > 0.2) c = Cesium.Color.fromCssColorString('#a5d6a7').withAlpha(alpha);
                else c = Cesium.Color.fromCssColorString('#e8f5e9').withAlpha(alpha);
                entity.polygon.material = c;
                entity.polygon.outline = false;
                entity.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
              }
            });
          }
          // Walkability grid layers — 6-step colour ramp (like RS grid)
          else if (layer.colorField) {
            const field = layer.colorField;
            const values = ds.entities.values
              .map(e => e.properties && e.properties[field] ? e.properties[field].getValue() : null)
              .filter(v => v !== null);
            const minVal = Math.min(...values);
            const maxVal = Math.max(...values);
            const range = maxVal - minVal || 1;
            // 6-step ramp from light to dark in each layer's hue
            const ramps = {
              '#4caf50': ['#e8f5e9','#a5d6a7','#66bb6a','#388e3c','#2e7d32','#1b5e20'], // green (walkability)
              '#2196f3': ['#e3f2fd','#90caf9','#42a5f5','#1e88e5','#1565c0','#0d47a1'], // blue (intersection)
              '#9c27b0': ['#f3e5f5','#ce93d8','#ab47bc','#8e24aa','#6a1b9a','#4a148c'], // purple (transit)
              '#ff9800': ['#fff3e0','#ffcc80','#ffa726','#f57c00','#e65100','#bf360c'], // orange (destination)
            };
            const ramp = ramps[layer.color] || ['#f7f7f7','#d9d9d9','#bdbdbd','#969696','#636363','#252525'];
            const alpha = 0.55;
            ds.entities.values.forEach(entity => {
              if (entity.polygon) {
                const props = entity.properties;
                const val = props && props[field] ? props[field].getValue() : null;
                let c;
                if (val !== null) {
                  const t = (val - minVal) / range;  // 0..1
                  const step = Math.min(Math.floor(t * 6), 5);
                  c = Cesium.Color.fromCssColorString(ramp[step]).withAlpha(alpha);
                } else {
                  c = Cesium.Color.GRAY.withAlpha(0.15);
                }
                entity.polygon.material = c;
                entity.polygon.outline = false;
                entity.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
              }
            });
          }
          // Polygon layers (e.g. height control zones)
          else if (layer.type === 'polygon') {
            const baseColor = Cesium.Color.fromCssColorString(layer.color);
            ds.entities.values.forEach(entity => {
              if (entity.polygon) {
                entity.polygon.material = baseColor.withAlpha(0.3);
                entity.polygon.outline = true;
                entity.polygon.outlineColor = baseColor;
                entity.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
              }
              // Add label with height control text
              const props = entity.properties;
              if (props && props.HT_CTL_TXT) {
                const htText = props.HT_CTL_TXT.getValue();
                if (htText) {
                  entity.label = new Cesium.LabelGraphics({
                    text: htText + ' sty',
                    font: 'bold 12px sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY,
                    scaleByDistance: new Cesium.NearFarScalar(500, 1.0, 5000, 0.4),
                  });
                }
              }
            });
          }
          // For point layers, override billboard with simple colored circles
          else if (layer.type === 'point') {
            ds.entities.values.forEach(entity => {
              if (entity.billboard) {
                entity.billboard = undefined;
                entity.point = new Cesium.PointGraphics({
                  pixelSize: 7,
                  color: Cesium.Color.fromCssColorString(layer.color),
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 1,
                  heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                  disableDepthTestDistance: Number.POSITIVE_INFINITY,
                });
              }
            });
          }
          viewer.dataSources.add(ds);
          layerState[id].dataSource = ds;
        } catch (err) {
          console.warn(`Failed to load layer ${layer.label}:`, err);
          layerState[id].loaded = false;
        }
        updateLayerLegend();
        return;
      }

      if (layerState[id].dataSource) {
        layerState[id].dataSource.show = visible;
      }
      if (layerState[id].imageryLayer) {
        layerState[id].imageryLayer.show = visible;
      }
      updateLayerLegend();
    }

    // ---------------------------------------------------------------
    // Choropleth heatmap
    // ---------------------------------------------------------------
    const CHOROPLETH_METRICS = [
      { value: '', label: 'Off' },
      { value: 'population_density', label: 'Population density', unit: '/km²', fmt: 'int' },
      { value: 'elderly_pct', label: 'Elderly share (65+)', unit: '%', fmt: 'pct', derived: true },
      { value: 'amenity_density', label: 'Amenity density', unit: '/km²', fmt: 'float' },
      { value: 'mrt_station_count', label: 'MRT stations', unit: '', fmt: 'int' },
      { value: 'cycling_path_km', label: 'Cycling paths', unit: ' km', fmt: 'float' },
      { value: 'park_connector_km', label: 'Park connectors', unit: ' km', fmt: 'float' },
      { value: 'resale_median_price', label: 'Resale flat price', unit: '', fmt: 'price' },
      { value: 'mean_height_m', label: 'Avg building height', unit: ' m', fmt: 'float' },
      { value: 'hdb_count', label: 'HDB blocks', unit: '', fmt: 'int' },
      { value: 'building_count', label: 'Total buildings', unit: '', fmt: 'int' },
      { value: 'max_height_m', label: 'Max building height', unit: ' m', fmt: 'float' },
      { value: 'resale_transaction_count', label: 'Resale transactions', unit: '', fmt: 'int' },
      { value: 'avg_hdb_year', label: 'Avg HDB year built', unit: '', fmt: 'int' },
      { value: 'total_dwelling_units', label: 'Dwelling units', unit: '', fmt: 'int' },
      { value: 'dwelling_density', label: 'Dwelling density', unit: '/km²', fmt: 'int' },
      { value: 'ndvi_mean', label: 'Vegetation (NDVI)', unit: '', fmt: 'float' },
      { value: 'ndbi_mean', label: 'Built-up (NDBI)', unit: '', fmt: 'float' },
      { value: 'lst_mean_c', label: 'Land Surface Temp', unit: ' °C', fmt: 'float' },
      { value: 'canopy_cover_pct', label: 'Tree canopy cover', unit: '%', fmt: 'float' },
      { value: 'ghsl_height_mean', label: 'GHSL building height', unit: ' m', fmt: 'float' },
      { value: 'dsm_mean', label: 'Surface elevation', unit: ' m', fmt: 'float' },
      { value: 'intersection_density', label: 'Intersection density', unit: '/km\u00B2', fmt: 'int' },
      { value: 'transit_access_score', label: 'Transit access', unit: '', fmt: 'float' },
      { value: 'destination_accessibility', label: 'Destination access', unit: '', fmt: 'float' },
      { value: 'walkability_index', label: 'Walkability (BEH-NWI)', unit: '', fmt: 'float' },
    ];

    const RAMP_COLORS = ['#ffffb2', '#fecc5c', '#fd8d3c', '#f03b20', '#bd0026'];
    const RAMP_CESIUM = RAMP_COLORS.map(c => Cesium.Color.fromCssColorString(c).withAlpha(0.55));
    const GRAY_COLOR = Cesium.Color.GRAY.withAlpha(0.25);

    let choroplethGeoJSON = null;
    let choroplethEntities = [];

    function getMetricValue(props, metricKey) {
      if (metricKey === 'elderly_pct') {
        const total = props.population_total;
        const elderly = props.population_elderly_65plus;
        if (!total || total === 0) return null;
        return (elderly / total) * 100;
      }
      const v = props[metricKey];
      return (v === null || v === undefined) ? null : v;
    }

    function formatValue(v, fmt, unit) {
      if (v === null || v === undefined) return '—';
      if (fmt === 'int') return v.toLocaleString() + unit;
      if (fmt === 'float') return v.toFixed(1) + unit;
      if (fmt === 'pct') return v.toFixed(1) + '%';
      if (fmt === 'price') return '$' + Math.round(v / 1000).toLocaleString() + 'K';
      return String(v) + unit;
    }

    function colorForValue(v, min, max) {
      if (v === null || v === undefined) return GRAY_COLOR;
      if (max === min) return RAMP_CESIUM[2];
      const t = (v - min) / (max - min);
      const idx = Math.min(Math.floor(t * RAMP_CESIUM.length), RAMP_CESIUM.length - 1);
      return RAMP_CESIUM[idx];
    }

    function coordsToHierarchy(coords, type) {
      const rings = [];
      if (type === 'MultiPolygon') {
        coords.forEach(poly => rings.push(poly[0]));
      } else {
        rings.push(coords[0]);
      }
      // Use first ring (largest polygon for MultiPolygon)
      const positions = rings[0].map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
      return new Cesium.PolygonHierarchy(positions);
    }

    async function updateChoropleth(metricKey) {
      const legend = document.getElementById('choropleth-legend');
      if (!metricKey) {
        choroplethEntities.forEach(e => { e.show = false; });
        legend.style.display = 'none';
        return;
      }

      // Lazy-load GeoJSON
      if (!choroplethGeoJSON) {
        const resp = await fetch('../geo/queenstown-subzone-summary.geojson');
        choroplethGeoJSON = await resp.json();
      }

      const features = choroplethGeoJSON.features;
      const metric = CHOROPLETH_METRICS.find(m => m.value === metricKey);

      // Create entities on first use
      if (choroplethEntities.length === 0) {
        features.forEach(feature => {
          const hierarchy = coordsToHierarchy(feature.geometry.coordinates, feature.geometry.type);
          const entity = viewer.entities.add({
            polygon: {
              hierarchy: hierarchy,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              material: GRAY_COLOR,
              outline: false,
            },
            properties: feature.properties,
          });
          choroplethEntities.push(entity);
        });
      }

      // Compute min/max
      const values = features.map(f => getMetricValue(f.properties, metricKey));
      const valid = values.filter(v => v !== null && v !== undefined);
      const min = Math.min(...valid);
      const max = Math.max(...valid);

      // Color each entity
      choroplethEntities.forEach((entity, i) => {
        const v = values[i];
        entity.polygon.material = colorForValue(v, min, max);
        entity.show = true;
      });

      // Update legend
      legend.style.display = 'block';
      document.getElementById('choropleth-min').textContent = formatValue(min, metric.fmt, metric.unit);
      document.getElementById('choropleth-max').textContent = formatValue(max, metric.fmt, metric.unit);
    }

    // ---------------------------------------------------------------
    // Dynamic layer legends
    // ---------------------------------------------------------------
    const LAYER_LEGEND_DEFS = {
      streetnet: {
        title: 'Betweenness centrality',
        type: 'discrete',
        items: [
          { color: '#ff5722', label: '> 0.01 (high)' },
          { color: '#ff9800', label: '0.005 – 0.01' },
          { color: '#ffeb3b', label: '0.002 – 0.005' },
          { color: '#00bcd4', label: '≤ 0.002 (low)' },
        ]
      },
      walk_idx: {
        title: 'Walkability index',
        type: 'discrete',
        items: [
          { color: '#1b5e20', label: 'High' },
          { color: '#2e7d32', label: '' },
          { color: '#388e3c', label: '' },
          { color: '#66bb6a', label: '' },
          { color: '#a5d6a7', label: '' },
          { color: '#e8f5e9', label: 'Low' },
        ]
      },
      walk_intdens: {
        title: 'Intersection density',
        type: 'discrete',
        items: [
          { color: '#0d47a1', label: 'High' },
          { color: '#1565c0', label: '' },
          { color: '#1e88e5', label: '' },
          { color: '#42a5f5', label: '' },
          { color: '#90caf9', label: '' },
          { color: '#e3f2fd', label: 'Low' },
        ]
      },
      walk_transit: {
        title: 'Transit access',
        type: 'discrete',
        items: [
          { color: '#4a148c', label: 'High' },
          { color: '#6a1b9a', label: '' },
          { color: '#8e24aa', label: '' },
          { color: '#ab47bc', label: '' },
          { color: '#ce93d8', label: '' },
          { color: '#f3e5f5', label: 'Low' },
        ]
      },
      walk_dest: {
        title: 'Destination access',
        type: 'discrete',
        items: [
          { color: '#bf360c', label: 'High' },
          { color: '#e65100', label: '' },
          { color: '#f57c00', label: '' },
          { color: '#ffa726', label: '' },
          { color: '#ffcc80', label: '' },
          { color: '#fff3e0', label: 'Low' },
        ]
      },
      rs_ndvi: {
        title: 'NDVI (vegetation)',
        type: 'gradient',
        gradient: 'linear-gradient(to right, #d73027, #fee08b, #1a9850)',
        min: '-0.2', max: '0.8',
      },
      rs_lst: {
        title: 'Land surface temperature',
        type: 'gradient',
        gradient: 'linear-gradient(to right, #2166ac, #f4a582, #b2182b)',
        min: '25 °C', max: '40 °C',
      },
      rs_ndbi: {
        title: 'Built-up index (NDBI)',
        type: 'gradient',
        gradient: 'linear-gradient(to right, #1a9850, #fee08b, #d73027)',
        min: '-0.3', max: '0.3',
      },
      rs_canopy: {
        title: 'Tree canopy cover',
        type: 'gradient',
        gradient: 'linear-gradient(to right, #ffffcc, #006837)',
        min: '0%', max: '100%',
      },
      rs_grid: {
        title: '100m grid (NDVI)',
        type: 'discrete',
        items: [
          { color: '#1b5e20', label: '> 0.6' },
          { color: '#2e7d32', label: '0.5 – 0.6' },
          { color: '#388e3c', label: '0.4 – 0.5' },
          { color: '#66bb6a', label: '0.3 – 0.4' },
          { color: '#a5d6a7', label: '0.2 – 0.3' },
          { color: '#e8f5e9', label: '≤ 0.2' },
        ]
      },
    };

    function updateLayerLegend() {
      const container = document.getElementById('layer-legend');
      let html = '';
      for (const [id, def] of Object.entries(LAYER_LEGEND_DEFS)) {
        if (!layerState[id] || !layerState[id].visible) continue;
        html += '<div class="layer-legend-section">';
        html += '<div class="layer-legend-title">' + def.title + '</div>';
        if (def.type === 'discrete') {
          def.items.forEach(item => {
            const lbl = item.label || '&nbsp;';
            html += '<div class="legend-item"><span class="legend-swatch" style="background:' + item.color + '"></span> ' + lbl + '</div>';
          });
        } else if (def.type === 'gradient') {
          html += '<div class="layer-legend-gradient" style="background:' + def.gradient + '"></div>';
          html += '<div class="layer-legend-labels"><span>' + def.min + '</span><span>' + def.max + '</span></div>';
        }
        html += '</div>';
      }
      container.innerHTML = html;
      container.style.display = html ? 'block' : 'none';
    }

    buildLayerPanel();

    // Basemap toggle
    function toggleBasemap() {
      const layers = viewer.imageryLayers;
      layers.remove(layers.get(0));
      isDark = !isDark;
      layers.addImageryProvider(isDark ? cartoDark : cartoLight, 0);
      const btn = document.getElementById('basemap-toggle');
      btn.innerHTML = isDark ? '&#9788; Light' : '&#9790; Dark';
    }
  </script>
</body>
</html>
